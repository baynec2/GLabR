max_insert_pmol =   (0.2 - max_vector_pmol)
}if(num_of_pieces == 3){
#testing
names = c("pUC19","CB020","CB23")
concentrations = c(26.1,55.0,55)
lengths = c(2686,861,100)
gibson_calculator(names,concentrations,lengths)
gibson_calculator = function(names,concentrations,lengths){
num_of_pieces = length(lengths)
#determining what ratio to use
#need to fix this piece of code, doesn't work as intended for the case where there are 3 parts.
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}if(num_of_pieces == 3){
#determining what ratio to use
#need to fix this piece of code, doesn't work as intended for the case where there are 3 parts.
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}else{if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}}else{
gibson_calculator = function(names,concentrations,lengths){
num_of_pieces = length(lengths)
#determining what ratio to use
#need to fix this piece of code, doesn't work as intended for the case where there are 3 parts.
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}else{if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}}else{
#testing
names = c("pUC19","CB020","CB23")
concentrations = c(26.1,55.0,55)
gibson_calculator = function(names,concentrations,lengths){
num_of_pieces = length(lengths)
#determining what ratio to use
#need to fix this piece of code, doesn't work as intended for the case where there are 3 parts.
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}else{if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}}else{
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}}else{
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}else{
ratio = 1
max_vector_pmol = 0.5/num_of_pieces
max_insert_pmol  = 0.5/num_of_pieces
}
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}else{
ratio = 1
max_vector_pmol = 0.5/num_of_pieces
max_insert_pmol  = 0.5/num_of_pieces
}
#determining mass of DNA needed to get the max molarity
#moles of dsDNA (mol) x ((length of dsDNA (bp) x 617.96 g/mol/bp) + 36.04 g/mol)
vector_mass_for_max_molarity = max_vector_pmol * 1E-12 * (lengths[1] * 617.96 + 36.04) /1E-9
gibson_calculator = function(names,concentrations,lengths){
num_of_pieces = length(lengths)
#determining what ratio to use
#need to fix this piece of code, doesn't work as intended for the case where there are 3 parts.
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}else{
ratio = 1
max_vector_pmol = 0.5/num_of_pieces
max_insert_pmol  = 0.5/num_of_pieces
}
#determining mass of DNA needed to get the max molarity
#moles of dsDNA (mol) x ((length of dsDNA (bp) x 617.96 g/mol/bp) + 36.04 g/mol)
vector_mass_for_max_molarity = max_vector_pmol * 1E-12 * (lengths[1] * 617.96 + 36.04) /1E-9
insert_masses_for_max_molarity = max_insert_pmol * 1E-12 * (lengths[2:num_of_pieces] * 617.96 + 36.04) / 1E-9
#can we achieve the max given volume constraints?
uL_vector = vector_mass_for_max_molarity / concentrations[1]
uL_insert = insert_masses_for_max_molarity / concentrations[2:num_of_pieces]
total_uL = uL_vector + sum(uL_insert)
#Adjusting the total volume to be 10 if it is not.
if(total_uL > 10){
adjustment = total_uL/10
uL_vector = uL_vector / adjustment
uL_insert = uL_insert / adjustment
vector_pmol = max_vector_pmol / adjustment
insert_pmol = max_insert_pmol / adjustment
}else{
vector_pmol = max_vector_pmol
insert_pmol = max_insert_pmol
}
pmol = c(vector_pmol,rep(insert_pmol,num_of_pieces-1))
uL = c(uL_vector,uL_insert)
df = tibble::tibble(names,pmol,uL)
#adding other components
water_uL = 10-  round(sum(df$uL),2)
water = list(names = "water",pmol = NA_real_,uL = water_uL)
MM = list(names = "2x MM", pmol = NA_real_, uL = 10)
df2 = dplyr::bind_rows(df,water,MM) %>%
dplyr::mutate(uL = round(uL,2))
return(df2)
}
#testing
names = c("pUC19","CB020","CB23")
concentrations = c(26.1,55.0,55)
lengths = c(2686,861,100)
gibson_calculator(names,concentrations,lengths)
gibson_calculator = function(names,concentrations,lengths){
num_of_pieces = length(lengths)
#determining what ratio to use
#need to fix this piece of code, doesn't work as intended for the case where there are 3 parts.
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}
else{
ratio = 1
max_vector_pmol = 0.5/num_of_pieces
max_insert_pmol  = 0.5/num_of_pieces
}
#determining mass of DNA needed to get the max molarity
#moles of dsDNA (mol) x ((length of dsDNA (bp) x 617.96 g/mol/bp) + 36.04 g/mol)
vector_mass_for_max_molarity = max_vector_pmol * 1E-12 * (lengths[1] * 617.96 + 36.04) /1E-9
insert_masses_for_max_molarity = max_insert_pmol * 1E-12 * (lengths[2:num_of_pieces] * 617.96 + 36.04) / 1E-9
#can we achieve the max given volume constraints?
uL_vector = vector_mass_for_max_molarity / concentrations[1]
uL_insert = insert_masses_for_max_molarity / concentrations[2:num_of_pieces]
total_uL = uL_vector + sum(uL_insert)
#Adjusting the total volume to be 10 if it is not.
if(total_uL > 10){
adjustment = total_uL/10
uL_vector = uL_vector / adjustment
uL_insert = uL_insert / adjustment
vector_pmol = max_vector_pmol / adjustment
insert_pmol = max_insert_pmol / adjustment
}else{
vector_pmol = max_vector_pmol
insert_pmol = max_insert_pmol
}
pmol = c(vector_pmol,rep(insert_pmol,num_of_pieces-1))
uL = c(uL_vector,uL_insert)
df = tibble::tibble(names,pmol,uL)
#adding other components
water_uL = 10-  round(sum(df$uL),2)
water = list(names = "water",pmol = NA_real_,uL = water_uL)
MM = list(names = "2x MM", pmol = NA_real_, uL = 10)
df2 = dplyr::bind_rows(df,water,MM) %>%
dplyr::mutate(uL = round(uL,2))
return(df2)
}
#testing
names = c("pUC19","CB020","CB23")
concentrations = c(26.1,55.0,55)
lengths = c(2686,861,100)
gibson_calculator(names,concentrations,lengths)
#testing
names = c("pUC19","CB020","CB23","CB020")
concentrations = c(26.1,55.0,55,100)
lengths = c(2686,861,100,100)
gibson_calculator(names,concentrations,lengths)
gibson_calculator = function(names,concentrations,lengths){
num_of_pieces = length(lengths)
#determining what ratio to use
#need to fix this piece of code, doesn't work as intended for the case where there are 3 parts.
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}
else{
ratio = 1
max_vector_pmol = 0.5/num_of_pieces
max_insert_pmol  = 0.5/num_of_pieces
}
#determining mass of DNA needed to get the max molarity
#moles of dsDNA (mol) x ((length of dsDNA (bp) x 617.96 g/mol/bp) + 36.04 g/mol)
vector_mass_for_max_molarity = max_vector_pmol * 1E-12 * (lengths[1] * 617.96 + 36.04) /1E-9
insert_masses_for_max_molarity = max_insert_pmol * 1E-12 * (lengths[2:num_of_pieces] * 617.96 + 36.04) / 1E-9
#can we achieve the max given volume constraints?
uL_vector = vector_mass_for_max_molarity / concentrations[1]
uL_insert = insert_masses_for_max_molarity / concentrations[2:num_of_pieces]
total_uL = uL_vector + sum(uL_insert)
#Adjusting the total volume to be 10 if it is not.
if(total_uL > 10){
adjustment = total_uL/10
uL_vector = uL_vector / adjustment
uL_insert = uL_insert / adjustment
vector_pmol = max_vector_pmol / adjustment
insert_pmol = max_insert_pmol / adjustment
}else{
vector_pmol = max_vector_pmol
insert_pmol = max_insert_pmol
}
pmol = c(vector_pmol,rep(insert_pmol,num_of_pieces-1))
uL = c(uL_vector,uL_insert)
df = tibble::tibble(names,pmol,uL)
#adding other components
water_uL = 10-  round(sum(df$uL),2)
water = list(names = "water",pmol = NA_real_,uL = water_uL)
MM = list(names = "2x MM", pmol = NA_real_, uL = 10)
df2 = dplyr::bind_rows(df,water,MM) %>%
dplyr::mutate(uL = round(uL,2))
return(df2)
}
#testing
names = c("pUC19","CB020","CB23","CB020")
concentrations = c(26.1,55.0,55,100)
lengths = c(2686,861,100,100)
gibson_calculator(names,concentrations,lengths)
gibson_calculator = function(names,concentrations,lengths){
num_of_pieces = length(lengths)
#determining what ratio to use
#need to fix this piece of code, doesn't work as intended for the case where there are 3 parts.
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}
else{
ratio = 1
max_vector_pmol = 0.5/num_of_pieces
max_insert_pmol  = 0.5/num_of_pieces
}
#determining mass of DNA needed to get the max molarity
#moles of dsDNA (mol) x ((length of dsDNA (bp) x 617.96 g/mol/bp) + 36.04 g/mol)
vector_mass_for_max_molarity = max_vector_pmol * 1E-12 * (lengths[1] * 617.96 + 36.04) /1E-9
insert_masses_for_max_molarity = max_insert_pmol * 1E-12 * (lengths[2:num_of_pieces] * 617.96 + 36.04) / 1E-9
#can we achieve the max given volume constraints?
uL_vector = vector_mass_for_max_molarity / concentrations[1]
uL_insert = insert_masses_for_max_molarity / concentrations[2:num_of_pieces]
total_uL = uL_vector + sum(uL_insert)
#Adjusting the total volume to be 10 if it is not.
if(total_uL > 10){
adjustment = total_uL/10
uL_vector = uL_vector / adjustment
uL_insert = uL_insert / adjustment
vector_pmol = max_vector_pmol / adjustment
insert_pmol = max_insert_pmol / adjustment
}else{
vector_pmol = max_vector_pmol
insert_pmol = max_insert_pmol
}
pmol = c(vector_pmol,rep(insert_pmol,num_of_pieces-1))
uL = c(uL_vector,uL_insert)
df = tibble::tibble(names,pmol,uL)
#adding other components
water_uL = 10-  round(sum(df$uL),2)
water = list(names = "water",pmol = NA_real_,uL = water_uL)
MM = list(names = "2x MM", pmol = NA_real_, uL = 10)
df2 = dplyr::bind_rows(df,water,MM) %>%
dplyr::mutate(uL = round(uL,2))
return(df2)
}
#testing
names = c("pUC19","CB020","CB23","CB020")
concentrations = c(26.1,55.0,55,100)
lengths = c(2686,861,100,100)
gibson_calculator(names,concentrations,lengths)
library(GLabR)
devtools::document()
library(GLabR)
library(tidyverse)
ggplot2::theme_set(ggprism::theme_prism(palette = "viridis"))
knitr::opts_chunk$set(echo = TRUE,warning = FALSE, message = FALSE)
names = c("pSET4s","CB022_F_CB017_R","CB019_F_CB023_R","CB018")
concentrations = c(31.0,46.6,73.7,41.4)
lengths = c(4506,1030,1030,971)
GLabR:::gibson_calculator(names,concentrations,lengths)
0.079*4
names = c("pSET4s","CB022_F_CB017_R","CB019_F_CB023_R","CB018")
concentrations = c(41.4,31.0,46.6,73.7)
lengths = c(4506,1030,1030,971)
GLabR:::gibson_calculator(names,concentrations,lengths)
127/41/4
127/41.4
29.03/31
29.03/31 * 2
num_of_pieces = length(lengths)
#determining what ratio to use
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}
else{
#determining mass of DNA needed to get the max molarity
#moles of dsDNA (mol) x ((length of dsDNA (bp) x 617.96 g/mol/bp) + 36.04 g/mol)
vector_mass_for_max_molarity = max_vector_pmol * 1E-12 * (lengths[1] * 617.96 + 36.04) /1E-9
insert_masses_for_max_molarity = max_insert_pmol * 1E-12 * (lengths[2:num_of_pieces] * 617.96 + 36.04) / 1E-9
#can we achieve the max given volume constraints?
uL_vector = vector_mass_for_max_molarity / concentrations[1]
uL_insert = insert_masses_for_max_molarity / concentrations[2:num_of_pieces]
total_uL = uL_vector + sum(uL_insert)
#Adjusting the total volume to be 10 if it is not.
if(total_uL > 10){
adjustment = total_uL/10
uL_vector = uL_vector / adjustment
uL_insert = uL_insert / adjustment
vector_pmol = max_vector_pmol / adjustment
insert_pmol = max_insert_pmol / adjustment
}else{
vector_pmol = max_vector_pmol
insert_pmol = max_insert_pmol
}
pmol = c(vector_pmol,rep(insert_pmol,num_of_pieces-1))
num_of_pieces = length(lengths)
#determining what ratio to use
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}
else{
#determining mass of DNA needed to get the max molarity
#moles of dsDNA (mol) x ((length of dsDNA (bp) x 617.96 g/mol/bp) + 36.04 g/mol)
vector_mass_for_max_molarity = max_vector_pmol * 1E-12 * (lengths[1] * 617.96 + 36.04) /1E-9
insert_masses_for_max_molarity = max_insert_pmol * 1E-12 * (lengths[2:num_of_pieces] * 617.96 + 36.04) / 1E-9
#can we achieve the max given volume constraints?
uL_vector = vector_mass_for_max_molarity / concentrations[1]
uL_insert = insert_masses_for_max_molarity / concentrations[2:num_of_pieces]
total_uL = uL_vector + sum(uL_insert)
num_of_pieces = length(lengths)
#determining what ratio to use
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}
else{
#determining mass of DNA needed to get the max molarity
#moles of dsDNA (mol) x ((length of dsDNA (bp) x 617.96 g/mol/bp) + 36.04 g/mol)
vector_mass_for_max_molarity = max_vector_pmol * 1E-12 * (lengths[1] * 617.96 + 36.04) /1E-9
num_of_pieces = length(lengths)
#determining what ratio to use
if(num_of_pieces == 2){
ratio = 0.5
max_vector_pmol = (0.2 / (num_of_pieces+1))
max_insert_pmol =   (0.2 - max_vector_pmol)
}
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}
else{
if(num_of_pieces == 3){
max_vector_pmol = 0.04
max_insert_pmol = 0.08
}else{
ratio = 1
max_vector_pmol = 0.5/num_of_pieces
max_insert_pmol  = 0.5/num_of_pieces
}
#determining mass of DNA needed to get the max molarity
#moles of dsDNA (mol) x ((length of dsDNA (bp) x 617.96 g/mol/bp) + 36.04 g/mol)
vector_mass_for_max_molarity = max_vector_pmol * 1E-12 * (lengths[1] * 617.96 + 36.04) /1E-9
insert_masses_for_max_molarity = max_insert_pmol * 1E-12 * (lengths[2:num_of_pieces] * 617.96 + 36.04) / 1E-9
#can we achieve the max given volume constraints?
uL_vector = vector_mass_for_max_molarity / concentrations[1]
uL_insert = insert_masses_for_max_molarity / concentrations[2:num_of_pieces]
total_uL = uL_vector + sum(uL_insert)
#Adjusting the total volume to be 10 if it is not.
if(total_uL > 10){
adjustment = total_uL/10
uL_vector = uL_vector / adjustment
uL_insert = uL_insert / adjustment
vector_pmol = max_vector_pmol / adjustment
insert_pmol = max_insert_pmol / adjustment
}else{
vector_pmol = max_vector_pmol
insert_pmol = max_insert_pmol
}
pmol = c(vector_pmol,rep(insert_pmol,num_of_pieces-1))
uL = c(uL_vector,uL_insert)
df = tibble::tibble(names,pmol,uL)
View(df)
253.6/41.4
253.9/41.4
names = c("pSET4s","CB022_F_CB017_R","CB019_F_CB023_R","CB018")
concentrations = c(41.4,31.0,46.6,60.1)
lengths = c(4506,1030,1030,971)
GLabR:::gibson_calculator(names,concentrations,lengths)
shiny::runApp('~/HiFi_Assembly_Calculator')
runApp('~/HiFi_Assembly_Calculator')
runApp('~/HiFi_Assembly_Calculator')
runApp('~/HiFi_Assembly_Calculator')
annotate_uniprot_single = function(protein_list,columns = NULL){
# BaseURL for request
baseUrl <- "https://rest.uniprot.org/uniprotkb/search?query=accession:"
# Adding OR term to do multiple proteins per request
#Initializing a data frame to hold results
output = data.frame()
for( i in 1:length(protein_list)){
#Iterating through the batches
temp_list = protein_list[[i]]
temp_string_list =  paste(temp_list, sep="", collapse="")
# Defining columns that we want to return. Defaults to default columns.
if(is.null(columns)){
request = paste0(baseUrl,temp_string_list,"&format=tsv","&size=",length(temp_list))
}else{
request = paste0(baseUrl,temp_string_list,"&format=tsv","&fields=",columns,"&size=",length(temp_list))
}
#Note this error handling will mean that the entire batch gets assigned as NA, not only any entries that may not exist.
#This is a problem, but it only seems to affect a very small amount of entries so I have decided to leave it as is.
returned_data = tryCatch({
# Try
read.csv(request, header = TRUE, sep = '\t')
},
# upon error do this...
error = function(cond){
message(paste("request does not seem to exist:", request))
message(paste("n_iteration: ", i))
return(NA)
}
)
output = rbind(output,returned_data)
#updating progress bar
setTxtProgressBar(pb, i)
}
output = tibble::as_tibble(output)
return(output)
}
annotate_uniprot_single(c("A0A5F9ZHS7","A0AVK6"))
annotate_uniprot_single = function(protein_list,columns = NULL){
# BaseURL for request
baseUrl <- "https://rest.uniprot.org/uniprotkb/search?query=accession:"
# Adding OR term to do multiple proteins per request
#Initializing a data frame to hold results
output = data.frame()
for( i in 1:length(protein_list)){
#Iterating through the batches
temp_list = protein_list[[i]]
temp_string_list =  paste(temp_list, sep="", collapse="")
# Defining columns that we want to return. Defaults to default columns.
if(is.null(columns)){
request = paste0(baseUrl,temp_string_list,"&format=tsv","&size=",length(temp_list))
}else{
request = paste0(baseUrl,temp_string_list,"&format=tsv","&fields=",columns,"&size=",length(temp_list))
}
#Note this error handling will mean that the entire batch gets assigned as NA, not only any entries that may not exist.
#This is a problem, but it only seems to affect a very small amount of entries so I have decided to leave it as is.
returned_data = tryCatch({
# Try
read.csv(request, header = TRUE, sep = '\t')
},
# upon error do this...
error = function(cond){
message(paste("request does not seem to exist:", request))
message(paste("n_iteration: ", i))
return(NA)
}
)
output = rbind(output,returned_data)
}
output = tibble::as_tibble(output)
return(output)
}
annotate_uniprot_single(c("A0A5F9ZHS7","A0AVK6"))
annotate_uniprot_single(c("A0A5F9ZHS7","A0AVK6","Q658P3"))
annotate_uniprot_single(c("A0A5F9ZHS7","A0AVK6","Q658Pdfas"))
annotate_uniprot_single(c("A0A5F9ZHS7","A0AVK6","Q658Pdfas","A0AVK6"))
devtools::document()
library(GLabR)
library(GLabR)
devtools::document()
library(GLabR)
library(GLabR)
